import { ComponentRef, TemplateRef, EventEmitter, RendererFactory2 } from '@angular/core';
import { ComponentLoaderFactory } from 'ngx-bootstrap/component-loader';
import { ModalBackdropComponent } from './modal-backdrop.component';
import { ModalOptions } from './modal-options.class';
import { BsModalRef } from './bs-modal-ref.service';
import * as ɵngcc0 from '@angular/core';
export declare class BsModalService {
    private clf;
    private modalDefaultOption;
    config: ModalOptions;
    onShow: EventEmitter<any>;
    onShown: EventEmitter<any>;
    onHide: EventEmitter<any>;
    onHidden: EventEmitter<any>;
    protected isBodyOverflowing: boolean;
    protected originalBodyPadding: number;
    protected scrollbarWidth: number;
    protected backdropRef: ComponentRef<ModalBackdropComponent>;
    private _backdropLoader;
    private modalsCount;
    private lastDismissReason;
    private loaders;
    private _renderer;
    constructor(rendererFactory: RendererFactory2, clf: ComponentLoaderFactory, modalDefaultOption: ModalOptions);
    /** Shows a modal */
    show<T = Object>(content: string | TemplateRef<any> | {
        new (...args: any[]): T;
    }, config?: ModalOptions<T>): BsModalRef<T>;
    hide(id?: number): void;
    _showBackdrop(): void;
    _hideBackdrop(): void;
    _showModal(content: any): BsModalRef;
    _hideModal(id?: number): void;
    getModalsCount(): number;
    setDismissReason(reason: string): void;
    removeBackdrop(): void;
    /** Checks if the body is overflowing and sets scrollbar width */
    /** @internal */
    checkScrollbar(): void;
    setScrollbar(): void;
    private resetScrollbar;
    private getScrollbarWidth;
    private _createLoaders;
    private removeLoaders;
    private copyEvent;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<BsModalService, [null, null, { optional: true; }]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<BsModalService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnMtbW9kYWwuc2VydmljZS5kLnRzIiwic291cmNlcyI6WyJicy1tb2RhbC5zZXJ2aWNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50UmVmLCBUZW1wbGF0ZVJlZiwgRXZlbnRFbWl0dGVyLCBSZW5kZXJlckZhY3RvcnkyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21wb25lbnRMb2FkZXJGYWN0b3J5IH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9jb21wb25lbnQtbG9hZGVyJztcbmltcG9ydCB7IE1vZGFsQmFja2Ryb3BDb21wb25lbnQgfSBmcm9tICcuL21vZGFsLWJhY2tkcm9wLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNb2RhbE9wdGlvbnMgfSBmcm9tICcuL21vZGFsLW9wdGlvbnMuY2xhc3MnO1xuaW1wb3J0IHsgQnNNb2RhbFJlZiB9IGZyb20gJy4vYnMtbW9kYWwtcmVmLnNlcnZpY2UnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQnNNb2RhbFNlcnZpY2Uge1xuICAgIHByaXZhdGUgY2xmO1xuICAgIHByaXZhdGUgbW9kYWxEZWZhdWx0T3B0aW9uO1xuICAgIGNvbmZpZzogTW9kYWxPcHRpb25zO1xuICAgIG9uU2hvdzogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgb25TaG93bjogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgb25IaWRlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBvbkhpZGRlbjogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgcHJvdGVjdGVkIGlzQm9keU92ZXJmbG93aW5nOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBvcmlnaW5hbEJvZHlQYWRkaW5nOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIHNjcm9sbGJhcldpZHRoOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGJhY2tkcm9wUmVmOiBDb21wb25lbnRSZWY8TW9kYWxCYWNrZHJvcENvbXBvbmVudD47XG4gICAgcHJpdmF0ZSBfYmFja2Ryb3BMb2FkZXI7XG4gICAgcHJpdmF0ZSBtb2RhbHNDb3VudDtcbiAgICBwcml2YXRlIGxhc3REaXNtaXNzUmVhc29uO1xuICAgIHByaXZhdGUgbG9hZGVycztcbiAgICBwcml2YXRlIF9yZW5kZXJlcjtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlckZhY3Rvcnk6IFJlbmRlcmVyRmFjdG9yeTIsIGNsZjogQ29tcG9uZW50TG9hZGVyRmFjdG9yeSwgbW9kYWxEZWZhdWx0T3B0aW9uOiBNb2RhbE9wdGlvbnMpO1xuICAgIC8qKiBTaG93cyBhIG1vZGFsICovXG4gICAgc2hvdzxUID0gT2JqZWN0Pihjb250ZW50OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+IHwge1xuICAgICAgICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDtcbiAgICB9LCBjb25maWc/OiBNb2RhbE9wdGlvbnM8VD4pOiBCc01vZGFsUmVmPFQ+O1xuICAgIGhpZGUoaWQ/OiBudW1iZXIpOiB2b2lkO1xuICAgIF9zaG93QmFja2Ryb3AoKTogdm9pZDtcbiAgICBfaGlkZUJhY2tkcm9wKCk6IHZvaWQ7XG4gICAgX3Nob3dNb2RhbChjb250ZW50OiBhbnkpOiBCc01vZGFsUmVmO1xuICAgIF9oaWRlTW9kYWwoaWQ/OiBudW1iZXIpOiB2b2lkO1xuICAgIGdldE1vZGFsc0NvdW50KCk6IG51bWJlcjtcbiAgICBzZXREaXNtaXNzUmVhc29uKHJlYXNvbjogc3RyaW5nKTogdm9pZDtcbiAgICByZW1vdmVCYWNrZHJvcCgpOiB2b2lkO1xuICAgIC8qKiBDaGVja3MgaWYgdGhlIGJvZHkgaXMgb3ZlcmZsb3dpbmcgYW5kIHNldHMgc2Nyb2xsYmFyIHdpZHRoICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNoZWNrU2Nyb2xsYmFyKCk6IHZvaWQ7XG4gICAgc2V0U2Nyb2xsYmFyKCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSByZXNldFNjcm9sbGJhcjtcbiAgICBwcml2YXRlIGdldFNjcm9sbGJhcldpZHRoO1xuICAgIHByaXZhdGUgX2NyZWF0ZUxvYWRlcnM7XG4gICAgcHJpdmF0ZSByZW1vdmVMb2FkZXJzO1xuICAgIHByaXZhdGUgY29weUV2ZW50O1xufVxuIl19